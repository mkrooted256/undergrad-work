% !TEX TS-program = xelatex
% !TEX encoding = UTF-8

\documentclass[11pt, a4paper]{article} % use larger type; default would be 10pt

\usepackage{fontspec} % Font selection for XeLaTeX; see fontspec.pdf for documentation
\defaultfontfeatures{Mapping=tex-text} % to support TeX conventions like ``---''
\usepackage{xunicode} % Unicode support for LaTeX character names (accents, European chars, etc)
\usepackage{xltxtra} % Extra customizations for XeLaTeX
\usepackage{tikz}
\usetikzlibrary{arrows,calc,patterns}
\usetikzlibrary{decorations.pathreplacing,calligraphy}

\setmainfont[Ligatures=TeX]{Garamond} % set the main body font (\textrm), assumes Charis SIL is installed
%\setsansfont{Deja Vu Sans}
\setmonofont[Ligatures=TeX]{Fira Code}

% other LaTeX packages.....
\usepackage{fullpage}
\usepackage[top=2cm, bottom=4.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd,systeme}
\usepackage{cancel}
\geometry{a4paper} 
%\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{multicol}

\renewcommand\lstlistingname{Algorithm}
\renewcommand\lstlistlistingname{Algorithms}
\def\lstlistingautorefname{Alg.}
\lstdefinestyle{mystyle}{
    % backgroundcolor=\color{backcolour},   
    % commentstyle=\color{codegreen},
    % keywordstyle=\color{magenta},
    % numberstyle=\tiny\color{codegray},
    % stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

\newcommand\course{5 - Complexity}
\newcommand\hwnumber{ДЗ №3}                   % <-- homework number
\newcommand\idgroup{ФІ-91}                
\newcommand\idname{Михайло Корешков}  

\usepackage[framemethod=TikZ]{mdframed}
\mdfsetup{%
	backgroundcolor = black!5,
}
\mdfdefinestyle{ans}{%
    backgroundcolor = green!5,
    linecolor = green!50,
    linewidth = 1pt,
}

\pagestyle{fancyplain}
\headheight 35pt
\lhead{\idgroup \\ \idname}
\chead{\textbf{\Large \hwnumber}}
\rhead{\course \\ \today}
\lfoot{}
\cfoot{}
\rfoot{\small\thepage}
\headsep 1.5em

\linespread{1.2}

\begin{document}

\section*{№ 3.2}
Let $N = \overline{1,1000}$.
Let $A = \{n\in N : n \text{ has digit '3'}\}$.

Let $A_0 = \{n \in N : n \% 10 = 3\}$ - all numbers with $3$ as the first digit.
$$A_0 = \{3,13,23,...,983,993\} = \{3 + 10k : k=\overline{0,99}\}$$
$$|A_0| = 100$$

Let $A_1 = \{n \in N : n \text{ has '3' as the second digit, but not the first}\}$.
$$A_1 = \{30, 31, ..., 39, 130, 131, ..., 139, 230, ..., 930, ...\} =$$
$$= \{100k + 30 + p : k=\overline{0,9}, p\in\{0,1,2,4,5,6,7,8,9\}\}$$
$$|A_1| = 10\cdot 9 = 90$$

Let $A_2 = \{n \in N : n \text{ has '3' as the third digit, but not 1st nor 2nd}\}$.
$$A_2 = \{300 + 10k + p : k\in\{0,1,2,4,5,6,7,8,9\}, p\in\{0,1,2,4,5,6,7,8,9\}\}$$
$$|A_2| = 9\cdot 9 = 81$$

Note that $A_0 \cap A_1 = A_0 \cap A_2 = A_1 \cap A_2 = \varnothing$. So,
$$A = A_0 \sqcup A_1 \sqcup A_2$$
$$|A| = \sum |A_i| = 100 + 90 + 81 = 271$$

\section*{№ 3.3}
\begin{mdframed}
    Let $\mathcal N$ - нумерація Геделя унарних обчислювальних функцій.\\
    That is, $\Phi_{\mathcal N} = \{\varphi_i\}$ - set of computable unary functions.

    Prove:
    $$\forall \mathcal N,\; f \in \Phi_\mathcal N,\; k\in \mathbb N:\; \exists n>k:\; \varphi_n \simeq \varphi_{f(n)}$$
\end{mdframed}


\begin{mdframed}[backgroundcolor=violet!25]
    \textbf{\Large Теорема про нерухому точку}

    Для довільної нумерацій Геделя унарних обчислювальних функцій $\Phi = \{\varphi_i\}$,
    довільної \textbf{всюди визначеної} унарної обчислювальної функції $f \in \Phi^{tot} \subset \Phi$, існує $n \in \mathbb N$ таке, що
    $$\varphi_n \simeq \varphi_{f(n)}$$
\end{mdframed}

Тобто різниця між теоремами в тому, що ми доводимо існування нескінченної кількості таких нерухомих точок.
\pagebreak



\begin{proof}
    Нехай 
    $$g(x) = \begin{cases}
        f(x), & x>k \\
        q : \varphi_q \simeq \varphi_x + 1, & x\le k
    \end{cases}$$
    $g$ - повністю визначена. Застосовуємо теорему про нерухому точку:

    $$\exists t\in\mathbb{N}: \varphi_{g(t)} \simeq \varphi_t$$
    
    Якщо $t > k$, то просто беремо $n = t$ бо
    $$\varphi_{g(t)} \simeq \varphi_{f(t)} \simeq \varphi_t$$

    Якщо $t \le k$, то маємо наступне:
    $$\varphi_{g(t)} \simeq \varphi_{q} \simeq \varphi_t$$
    При цьому 
    $$\varphi_q \simeq \varphi_t + 1$$
    Тобто 
    $$\varphi_t \simeq \varphi_t + 1$$
    Протиріччя. Значить $t > k$.
\end{proof}


\section*{№ 3.4}
\begin{mdframed}
    Prove
    $$\forall \mathcal N, f \in \Phi^{tot}: \exists n: Range_n = Range_{\varphi_n}$$
\end{mdframed}
Застосуємо теорему про нерухому точку.
$$\exists n:\; \forall x:\; \varphi_n(x) \simeq \varphi_{f(n)}(x)$$
$$Range_n = \{\varphi_n(x) : x \in \mathbb N\} = \{\varphi_{f(n)} : x \in \mathbb{N}\} = Range_{f(n)}$$
\qedsymbol

\section*{№ 3.5}
\begin{mdframed}
    \begin{itemize}
        \item Микола знає колір
        \item Іван знає форму
        \item Всі (вони також) знають, що їм це сказали, але не знають, що саме
    \end{itemize}
\end{mdframed}
"Хто-небудь знає точно, де сюрприз?" - всі мовчать

Є лише одна жовта фігура та лише один квадрат. Микола з Іваном мовчать, бо не знають точно. 
Значить їм сказали, що фігура не жовта та не квадратна. \\ 
Залишились червоний трикутник, червоний круг та синій трикутник. 

"Тепер хто-небудь знає точно, де сюрприз?" - всі мовчать

Це означає, що Миколі сказали, що фігура має червоний колір, а Івану - що фігура трикутна. 
Інакше Микола чи Іван би точно знали фігуру.

В нас тільки одна червона трикутна фігура.

\section*{№ 3.6}
\begin{mdframed}
    $M$ -  машина Тюрінга.

    Довести, що задача "чи прийме $M$ слово $w$" - нерозв'язна за Тюрінгом.
\end{mdframed}

Нехай задача розв'язна за Тюрінгом. 
Це означає, що існує МТ $M_{acc}(M,w)$ така, що приймає МТ $M$, слово $w$ та відповідає за скінченну кількість тактів на питання "чи не зациклюється $M$ на слові $w$?"
При чому $M_acc$ приймає саме двійкові представлення.

$$M_{acc}(M, w) = \begin{cases}
    1 , & M(w) \ne \bot\\
    0 , & M(w) = \bot
\end{cases}$$

Нехай $$M_d(w) = M_{acc}(w, w)$$

Нехай $$M_1(w) = \begin{cases}
    \bot, M_d(w) = 1\\
    0, M_d(w) = 0
\end{cases}$$

$$M_1(M_1) = ?$$
\begin{align*}
    M_1(M_1) = 0 &\implies M_d(M_1) = 0 \implies M_{acc}(M_1, M_1) = 0 \implies M_1(M_1) = \bot \implies \\
& \implies  M_d(M_1) = 1 \implies M_1(M_1) = \bot
\end{align*}
Протиріччя. Значить $M_1(M_1) \ne 0$
$$M_1(M_1) = \bot \implies M_d(M_1) = 1 \implies M_{acc}(M_1,M_1) = 1 \implies M_1(M_1) \ne \bot$$
Протиріччя. Значить $M_1(M_1) \ne \bot$.

Але ми вичерпали всі можливі значення $M_1(w)$. Значить неможливо побудувати $M_1$.
Єдине припущення, яке ми використали - існування $M_{acc}$. Значить, $M_{acc}$ не існує.
\qedsymbol

\section*{№ 3.7}
\begin{mdframed}
    Доведiть, що множина вирiшуваних за Тюрiнгом мов є замкненою вiдносно
операцiй об’єднання, перетину та конкатенацiї мов, а також вiдносно операцiї
замикання Клiнi та доповнення мови.
\end{mdframed}

Нехай $L_1, L_2$ - вирішувані за Тюрiнгом.
Тобто існують $M_1, M_2$ такі, що приймають будь-яке слово та
$$M_1(w) = \chi_{L_1}(w)$$
$$M_2(w) = \chi_{L_2}(w)$$
де $\chi_A(x) = \begin{cases}
    1, x\in A\\
    0, x\notin A
\end{cases}$.

\subsection*{1. Об'єднання}
$$L = L_1 \cup L_2$$.
Будуємо МТ $M$ за таким принципом:
\begin{itemize}
    \item Обчислюємо $a=M_1(w)$ та $b=M_2(w)$
    \subitem Ці операції гарантовано скінченні
    \item Повертаємо $a \vee b$ 
\end{itemize}

$$M(w) = 1 \iff M_1(w) = 1 \vee M_2(w) = 1 \iff w \in L_1 \cup L_2$$
\qedsymbol

\subsection*{2. Перетин}
Аналогічно попередньому пункту, але $M$ повертає $M_1(w) \wedge M_2(w)$.
\qedsymbol

\subsection*{3. Конкатенація мов}
$$L = L_1 \cdot L_2 = \{ab : a \in L_1, b \in L_2\}$$.
Будуємо МТ $M^{L_1 \cdot L_2}$ за таким принципом:
\begin{itemize}
    \item Приймаємо на вхід слово $w$
    \item Обчислюємо $a = \left(M_1(\varepsilon) \wedge M_2(w)\right) \vee \left(M_1(w) \wedge M_2(\varepsilon)\right)$\\    
    Якщо $a = 1$, то повертаємо 1 і завершуємо роботу.
    \item Проходимо по кожному символу слова.\\
    \begin{itemize}
        \item Обчислюємо $b = M_1(u) \wedge M_2(v)$, де $u$ - частина $w$ до зчитувача, $v$ - частина $w$ після зчитувача (включно).
        \item Якщо $b = 1$, то повертаємо 1.
        \item Якщо ні, то рухаємо зчитувач на один символ праворуч
    \end{itemize}
    \item Якщо дійшли до кінця (тобто ні разу не отримали $b=1$), то повертаємо 0
\end{itemize}

$$M(w) = \bigvee_{k=1}^{|w|} M_1(w_1 ... w_k) \wedge M_2(w_{k+1}...w_|w|) \vee \left(\left(M_1(\varepsilon) \wedge M_2(w)\right) \vee \left(M_1(w) \wedge M_2(\varepsilon)\right)\right)$$
\qedsymbol

\subsection*{4. Замикання Кліні}
$$L = L_1^* = \{\varepsilon\}\cup \bigcup_{n=1}^{\infty} L_1^n$$.
$L_1^n$ - Конкатенація мови з собою $n-1$ разів.

\begin{mdframed}[backgroundcolor=violet!10]
    Нехай $\varepsilon \notin L$. Нехай $d = \min_{w \in L} |w|$.
    
    Тоді $$\forall n > \left\lceil\frac{|w|}{d}\right\rceil: w \notin L*$$
    \begin{proof}
        Припустимо, що $$w \in L^n,\; n > \left\lceil\frac{|w|}{d}\right\rceil$$
        Тоді $dn > d\left\lceil\frac{|w|}{d}\right\rceil \ge |w|$.
        Тобто довжина $w$ менша за найменшу можливу довжину слова в $L^n$.
        Тобто $w \notin L^n$ 
    \end{proof}
\end{mdframed}
Маємо, що нам не потрібно перевіряти належність $w$ до $\bigcup_{n=1}^{\infty} L_1^n$. 
Лише до $\bigcup_{n=1}^{d} L_1^n$, де $d = \left\lceil\frac{|w|}{d}\right\rceil < \infty$.

$L^2 = L_1 \cdot L_1$. Для цієї мови існує вирішувач $M^2$ (побудований згідно пункта 3).
Аналогічно існує вирішувач $M^3$ для $L^3 = L^2 \cdot L$ та $M^n$ для $L^n = L^{n-1} \cdot L$.

Будуємо МТ $M^*$, що обчислює $\bigvee_{n=1}^{d} M^n(w) \vee (w=\varepsilon)$.
Вона виконає скінченну кілкьість тактів і завжди поверне результат.
\qedsymbol

\subsection*{5. Доповнення}
$$L = \overline{L_1}$$
Будуємо МТ $M'$ таку що $M'(w) = 1 - M_1(w)$. Просто заперечення $M_1(w)$. \qedsymbol

\section*{№ 3.8}
\begin{mdframed}
    Доведiть, що множина мов, якi розпiзнаються за Тюрiнгом, є замкненою
вiдносно операцiй об’єднання, перетину та конкатенацiї мов, а також вiдносно
операцiї замикання Клiнi. Доведiть, що множина мов, якi розпiзнаються за
Тюрiнгом, не є замкненою вiдносно операцiї доповнення мови.
\end{mdframed}

Нехай $L_1, L_2$ - розпізнаються за Тюрiнгом.
Тобто існують $M_1, M_2$ такі, що
$$M_1(w) = \chi'_{L_1}(w)$$
$$M_2(w) = \chi'_{L_2}(w)$$
де $\chi'_A(x) = \begin{cases}
    1, x\in A\\
    0 \text{ або } \bot, x\notin A
\end{cases}$.

\subsection*{1. Об'єднання}
$$L = L_1 \cup L_2$$.
Будуємо МТ $M$ за таким принципом:\\
Обчислюємо $a=M_1(w)$ та $b=M_2(w)$. 
Але не послідовно, а "паралельно". Виконуємо один такт $M_1$, потім один такт $M_2$ і так далі.
\begin{itemize}
    \item Якщо одна з машин повернула $1$ - повертаємо $1$ і зупиняємось.
    \item Якщо одна з машин повернула $0$ - продовжуємо виконувати такти іншої машини.
    \item Якщо обидві машини повернули $0$ - повертаємо $0$
\end{itemize}
В результаті: 
$$w \in L \implies M_1(w) = 1 \vee M_2(w) = 1 \implies M(w) = 1$$
$$w \notin L \implies \left[ \begin{matrix}
    M_1(w) = 0 \wedge M_2(w) = 0 & \implies M(w) = 0\\
    M_1(w) = \bot \wedge M_2(w) = \bot & \implies M(w) = \bot\\
    M_1(w) = \bot \wedge M_2(w) = 0 & \implies M(w) = \bot\\
    M_1(w) = 0 \wedge M_2(w) = 0 & \implies M(w) = \bot
\end{matrix} \right.$$
\qedsymbol

\subsection*{2. Перетин}
Тут взагалі просто. 
\begin{itemize}
    \item Обчислюємо $a=M_1(w)$ та $b=M_2(w)$ послідовно. 
    \item Якщо хоча б одна підмашина зациклилась, то вся машина зациклилась - нас це влаштовує.
    \item Якщо хоча б одна підмашина повернула 0, то повертаємо 0.  
    \item Якщо обидві машини повернули 1 - повертаємо 1
\end{itemize}
\qedsymbol

\subsection*{3. Конкатенація мов}
$$L = L_1 \cdot L_2 = \{ab : a \in L_1, b \in L_2\}$$.
Будуємо МТ $M^{L_1 \cdot L_2}$ за таким принципом:
\begin{itemize}
    \item Приймаємо на вхід слово $w$
    \item Створюємо лічильник $N = 1$
    \item Проходимо по кожному символу слова:
    \begin{itemize}
        \item Обчислюємо \textbf{з обмеженням на максимальну кількість тактів $=N$}:\\
        $b_k = M_1(u) \wedge M_2(v)$, де $u$ - частина $w$ до зчитувача, $v$ - частина $w$ після зчитувача (включно).
        \item Якщо $b = 1$, то повертаємо 1 та завершуємо работу всієї машини.
        \item Якщо ні, то рухаємо зчитувач на один символ праворуч
    \end{itemize}
    \item Обчислюємо \textbf{з обмеженням на максимальну кількість тактів $=N$}:\\
    $a = \left(M_1(\varepsilon) \wedge M_2(w)\right) \vee \left(M_1(w) \wedge M_2(\varepsilon)\right)$ 
    \item Якщо $a = 1$, то повертаємо 1 та завершуємо работу всієї машини.
    \item Якщо дійшли до кінця (тобто ні разу не отримали $1$), то \textbf{збільшуємо лічильник} ($N := N+1$) та починаємо заново.
\end{itemize}

В результаті:
$$w \in L \implies \exists k,N:\; b_k=1 \text{за $N<\infty$ кроків} \implies M^{L_1 \cdot L_2}(w) = 1$$
$$w \notin L \implies $$
$\implies$ нескінченно збільшуємо $N$, бо всі підмашини чи зациклились, чи повернули $0$ $\implies$ 
$$\implies M^{L_1 \cdot L_2}(w) = \bot$$

\qedsymbol

\subsection*{4. Замикання Кліні}
$$L = L_1^*$$
Ми маємо МТ $M^{L_1\cdot L_2}$, що розпізнає конкатенацiї - можемо розпізнавати $L^n$.

Нехай $M^0(w)$ - розпізнавач (насправді вирішувач) мови $\{\varepsilon\}$.\\
Нехай $M^n(w)$ - розпізнавач мови $L^n$.\\
Нехай $d = \left\lceil\frac{|w|}{d}\right\rceil (< \infty)$

\begin{itemize}
    \item Приймаємо на вхід слово $w$
    \item Створюємо лічильник $N = 1$
    \begin{itemize}
        \item Обчислюємо $M^0(w), M^1(w), ..., M^d(w)$. 
        Кожну підмашину запускаємо з обмеженням на максимальну кількість тактів $= N$.
        \item Якщо хоча б одна повернула $1$, то повертаємо $1$ та завершуємо роботу всієї машини
        \item Інакше $N := N + 1$ та починаємо спочатку.
    \end{itemize}
\end{itemize}
\qedsymbol

\subsection*{5. Доповнення}
\label{3.8.5}
$$L = \overline{L_1}$$

Нехай $L та L_1$ мають розпізнавачі. Нехай розпізнавач $L$ це $M$, розпізнавач $L_1$ це $M_1$. Тоді побудуємо МТ $M'$:
\begin{itemize}
    \item Приймаємо на вхід слово $w$
    \item Створюємо лічильник $N = 1$
    \begin{itemize}
        \item Обчислюємо $M(w)$ та $M_1(w)$. 
        Кожну підмашину запускаємо з обмеженням на максимальну кількість тактів $= N$.
        \item Якщо $M(w)$ завершила роботу та $M(w) = 1$, то повертаємо $0$ та завершуємо роботу всієї машини.
        \item Якщо $M(w)$ завершила роботу та $M(w) = 0$, то повертаємо $1$ та завершуємо роботу всієї машини.
        \item Якщо $M_1(w)$ завершила роботу та $M_1(w) = 1$, то повертаємо $1$ та завершуємо роботу всієї машини.
        \item Якщо $M_1(w)$ завершила роботу та $M_1(w) = 0$, то повертаємо $0$ та завершуємо роботу всієї машини.
        \item Інакше $N := N + 1$ та починаємо спочатку.
    \end{itemize}
\end{itemize}

Оскільки $w \in \Sigma^* = L \sqcup L_1$, то $w \in L$ або $w \in L_1$. 
Тобто одна за машин $M, M_1$ точно завершить роботу з $1$. 
Це означає, що машина $M'$ гарантовано завершить роботу і поверне $1$ чи $0$.
Це означає, що $L$ та $L_1$ - вирішувані. Але за припущенням $L_1$ має лише розпізнавач і не є вирішуваною.
Протиріччя.

Тобто, розпізнавача $\overline{L_1}$ не має існувати. \qedsymbol

\section*{№ 3.9}
\begin{mdframed}
    Доведiть, що мова L1 є вирiшуваною за Тюрiнгом тодi й тiльки тодi, коли
вона та її доповнення, мова L1, розпiзнаються за Тюрiнгом.
\end{mdframed}

\section*{Туди $\implies$}
Нехай $L_1$ є вирiшуваною за Тюрiнгом. 
Тоді існує МТ-вирішувач $M_1$ такий що $M_1(w) = \begin{cases}
    1, w \in L_1\\
    0, w \notin L_1
\end{cases}$.

$M_1$ також є і розпізнавачем $L_1$.
$M'_1(w) = 1 - M_1(w)$ є розпізнавачем $\overline{L_1}$.
\qedsymbol

\section*{Сюди $\impliedby$}
\hyperref[3.8.5]{Доведено в пункті 5 попередньої задачі (№ 3.8)}

\section*{№ 3.10.a)}
\begin{mdframed}
    задача досяжностi стану USELESS, яка для заданої машини Тюрiнга
визначає чи має вона хоча б один внутрiшнiй стан, в який ця машина
Тюрiнга не попадає за будь-якого вхiдного слова;
\end{mdframed}

По-перше, властивість $USELESS(M)$, яку ми намагаємось детектувати, не є інваріантною:
\begin{proof}
    Нехай $L_1 = \{\varepsilon\}$.
    Нехай $M$ - вирішувач мови $L_1$ такий, що не має useless станів.
    Нехай $M'$ - це $M$ із доданим useless станом.
    
    $L(M) = L(M')$, $M \notin USELESS$ але $M' \in USELESS$
\end{proof}
Теорема Райса не застосовна.

Схема кодування відома. Машина може відновити $M$ за її кодом. 
Значить, машина за закодованим описом МТ $M$ знайде стан, в який неможливо перейти. 

\begin{mdframed}[style=ans]
    Вирішувана
\end{mdframed}


\section*{№ 3.10.б)}
\begin{mdframed}
    задача розпiзнавання всiх машин Тюрiнга, якi напишуть бодай один
    непорожнiй символ, отримавши на вхiд порожнє слово;
\end{mdframed}

Моделюємо роботу МТ $M$.
Чекаємо зупинки.
Якщо зупиняємось не записавши ні один непорожнiй символ - повертаємо 0. Інакше - 1.

Питання в випадку, коли машина $M$ зациклюється на порожньому слові. 
Вона може не записати ні одного слова за всю роботу, але ми ніколи не будемо певні в цьому, поки вона не зупиниться.

Припустимо, що існує МТ $M_{\varepsilon}(M) = \begin{cases}
    1, |M(\varepsilon)| > 0\\
    0, |M(\varepsilon)| = 0
\end{cases}$.

Будуємо МТ $M_1(M,w)$ таким чином, що вона моделює роботу $M$ та:
\begin{itemize}
    \item зупиниться з відповіддю "1" якщо $M$ зупинилась на вхідному слові $w$
    \item Інакше вона просто нескінченно моделює виконання $M(w)$ та \textbf{нічого} не пише.
\end{itemize}

Будуємо МТ $M_w(u) = M_1(M,wu)$, де $wu$ - це конкатенація. 

$M_\varepsilon(M_w) = 1 \implies |M_w(\varepsilon)| > 0 \implies |M_1(M,w)| > 0 \implies $ $M$ завершила роботу на вхідному слові $w$.

$M_\varepsilon(M_w) = 0 \implies |M_w(\varepsilon)| = 0 \implies |M_1(M,w)| = 0 \implies $ $M$ зациклилась на вхідному слові $w$.

Тобто існування $M_\varepsilon \implies $ задача HALT вирішувана. Протиріччя.

\subsection*{теорема Райса}
не знайшов як представити задачу через властивість мови

\begin{mdframed}[backgroundcolor=red!20]
    Невирішувана
\end{mdframed}

\subsection*{№ 3.10.в)}
\begin{mdframed}
    задача, яка для заданої машини Тюрiнга визначає чи зробить вона хоч на
одному тактi перемiщення зчитувального пристрою влiво, коли на її вхiд
подається задане слово;
\end{mdframed}

Нехай існує $M_<(M,w) = \begin{cases}
    1, $M$ на $w$ зробить вона хоч одне перемiщення зчитувача влiво\\
    0, $M$ на $w$ не зробить перемiщення зчитувача влiво ні разу\\
\end{cases}$

Будуємо $M_1(M,w)$ таку, що моделює роботу $M(w)$ із наступними модифікаціями:
\begin{itemize}
    \item Якщо $M$ зупинилась, $M_1$ рухає зчитувач ліворуч.
    \item В усіх інших випадках $M_1$ не рухає зчитувач ліворуч (це і не потрібно).
\end{itemize}

Нехай $M_2(M,w) = M_<(M'_{M}, w)$, де $M'_{M}(w) = M_1(M,w)$

$M_2(M,w) = 1 \implies $ $M'_M$ на $w$ зробить вона хоч одне перемiщення зчитувача влiво $\implies $
$M_1$ на $(M,w)$ зробить вона хоч одне перемiщення зчитувача влiво $\implies M$ зупинилась на $w$.

$M_2(M,w) = 0 \implies $ $M'_M$ на $w$ ніколи не рухає зчитувач влiво $\implies $
$M_1$ на $(M,w)$ ніколи не рухає зчитувач влiво $\implies M$ не зупиняється на $w$.

Тобто $M_2(M,w)$ розвязує задачу HALT. Протиріччя.
\begin{mdframed}[backgroundcolor=red!20]
    Невирішувана
\end{mdframed}

\subsection*{№ 3.10.г)}
\begin{mdframed}
    задача розпiзнавання всiх машин Тюрiнга, якi зроблять принаймнi 100
тактiв з кожним вхiдним словом;
\end{mdframed}
Знову, ця властивість не залежить від мови МТ, бо завжди можна додати до МТ 100 непотрібних кроків не змінюючи її мову розпізнавання.
Тобто, теорема Райса не застосовна.

Нехай існує МТ $M_{100}(M) = \begin{cases}
    1, \forall w: M(w) \text{зробить не менше 100 кроків}\\
    0, \exists w: M(w) \text{зробить менше 100 кроків}
\end{cases}$

Тобто $L_P = \{<M> : \forall w: M $ на $w$ зупиняється більше ніж через 100 кроків чи не зупиняється$\}$

$\overline{L_P} = \{<M> : \exists w: M $ на $w$ обов'язково зупиняється менш ніж через 100 кроків$\}$

1. Перебираємо усі $w \in \bigcup_{n=0}^{101} {0,1}^n$
2. Якщо на якомусь вході $M$ зупиняється менш, ніж за 100 кроків, то повертаємо 0
3. Інакше повертаємо 1

Це працює, бо якщо на вхід $M$ йде слово $w$ довжини $|w|>101$, є такі варіанти:
\begin{itemize}
    \item $M$ завжди дає відповідь лише після читання $100 < n \le |w|$ символів цього слова.\\
    У цьому випадку гарантовано робимо не менше 100 кроків хоча б щоб прочитати слово. 
    Можна повертати 1, якщо ще не повернули 0.
    \item Нехай $|w| > 101$, $M$ на $w$ виконує $n < 100$ кроків, та для всіх $w' : |w'|\le 101$ $M$ робить більше 100 кроків.\\
    Тоді $M$ прочитала не більше $n < 100$ символів слова $w$. 
    Але ми вже перевірили всі реакції $M$ на слова розміру менше 100 і знаємо, що в таких випадках $M$ завжди робить більше 100 кроків.
    Протиріччя. \\ Тобто $\forall w: |w| > 101$, $M$ на $w$ виконує $n \ge 100$ кроків
\end{itemize}

\begin{mdframed}[style=ans]
    Вирішувана
\end{mdframed}

\subsection*{№ 3.10.e}
\begin{mdframed}
    задача розпiзнавання всiх машин Тюрiнга, якi зупиняються на кожному
вхiдному словi.
\end{mdframed}

Нехай існує $M_{\forall HALT}(M) = \begin{cases}
    1, \forall x: M(x) \ne \bot\\
    0, \exists x: M(x) = \bot
\end{cases}$

Нехай $M'_{M,w}(x) = \begin{cases}
    M(x), w = x\\
    0, w \ne x
\end{cases}$

Note: $M'_{M,w}$ може зациклитись лише на вході $x=w$

$$M_1(M,w) = M_{\forall HALT}(M'{M,w}) = 0 \iff \exists x: M'{M,w}(x) = \bot \iff M(w) = \bot \iff M_{HALT}(M,w) = 0$$
$$M_1(M,w) = M_{\forall HALT}(M'{M,w}) = 1 \iff \forall x: M'{M,w}(x) \ne \bot \iff M(w) \ne \bot \iff M_{HALT}(M,w) = 1$$

Тобто реалізували $M_{HALT}$. Протиріччя.
\begin{mdframed}[backgroundcolor=red!20]
    Невирішувана
\end{mdframed}



\subsection*{№ 3.10.д)}
\begin{mdframed}
    задача розпiзнавання всiх машин Тюрiнга, якi зупиняються на кожному
    вхiдному словi з парною кiлькiстю символiв;
\end{mdframed}

Нехай існує $M_{even\implies halt}(M) = \begin{cases}
    1, \forall w: |w|\vdots 2 \implies M(w) \ne \bot\\
    0, \exists w: |w|\vdots 2 \wedge M(w) = \bot
\end{cases}$

Будуємо $M_{mul2}(w,n) = w_1a(n)_1w_2a(n)_2...w_{|w|}a(n)_{|w|}$, 
де a(n) - отримання $a \in A = {0,1}^|w|$, де множина $A$ занумерована деяким чином. 

Будуємо $M_{div2}(w) = w_1w_3w_5...w_{|w|/2-1}$.

Будуємо $M_{1M}(x) = M(M_{div2}(x))$

$$M_{even\implies halt}(M_{1M}) = 1 \iff \forall w: |w|\vdots 2 \implies M_{1M}(w) \ne \bot \iff$$
$$\implies \iff w': M(w') \ne \bot \iff M_{HALT}(M) = 1$$

Тобто 
$$M_{HALT}(M) = M_{even\implies halt}(M_{1M})$$ - ми реалізували вирішувач задачі HALT. Протиріччя.

\begin{mdframed}[backgroundcolor=red!20]
    Невирішувана
\end{mdframed}


\pagebreak

\section*{№ 3.11.a)}
\begin{mdframed}
    $L_{11} = \{<M> : \text{машина Тюрiнга M приймає вхiдне слово} 11\} \subseteq \{0, 1\}$
\end{mdframed}

\subsection*{теорема Райса}
$$M_1, M_2 \in L_{11} \iff L(M_1), L(M_2) \ni 11$$
Тобто це дійсно властивість мови. 

Нехай $M_1$ приймає всі слова, $M_2$ відхиляє всі слова. $M_1 \in L_{11}, M_2 \notin L_{11}$. 
Значить, властивість нетривіальна. Тобто, невирішувана


\subsection*{зведення до іншої задачі}

\begin{proof}
    Ми знаємо, що $\overline{HALT}$ - не рекурсивно зліченна. 

    Нехай $L_{11}$ - рекурсивно зліченна. Значить існує $M_{11}(M) = \begin{cases}
        1, M(11) = 1\\
        0 \text{ або } \bot, M(11) = 0 \vee M(11) = \bot
    \end{cases}$

    $M'_{M,w}(y) = \begin{cases}
        1,& M(w) = 1 \vee M(w) = 0\\
        \bot, & M(w) = \bot
    \end{cases}$
    Тобто $\forall y,w: M'_{M,w}(y) \ne 0$ та $M'_{M,w}(y)$ ігнорує $y$.

    $M''(M,w) = 1 - M_{11}(M'_{M,w})$

    $$M''(M,w) = 1 \iff M_{11}(M'_{M,w}) = 0 \iff \left(M'_{M,w}(11) = 0 \vee M'_{M,w}(11) = \bot \right) \iff$$
    $$\iff M'_{M,w}(11) = \bot \iff M(w) = \bot$$

    Тобто $M''(M,w) \simeq T_{\overline{HALT}}(M,w)$.
    Протиріччя.
\end{proof}
Значить, $L_{11}$ - не рекурсивно зліченна.


\begin{mdframed}[backgroundcolor=red!20]
    \begin{itemize}
        \item Невирішувана
        \item Не рекурсивно зліченна
    \end{itemize}
\end{mdframed}

\section*{№ 3.11.б)}
\begin{mdframed}
    $L_{1024} = \{<M> : \text{машина M зробить > 1024 тактів хоча б на одному вході}\}$
\end{mdframed}

Це не властивість мови. Теорема Райса не застосовна

Будуємо розпізнавач.
\begin{itemize}
    \item Даємо на вхід $M$ всі можливі слова та зупиняємось на 1025-му кроці або разом з $M$ (дивлячись що раніше)
    \item Якщо машина M робить > 1024 тактів хоча б на одному вході, то ми точно рано чи пізно знайдемо цей вхід.
    \item Інакше зациклюємось 
\end{itemize}

$M_{1024}(M) = \begin{cases}
    1,& \exists w: T_M(w) > 1024\\
    \bot, & \forall w: T_M(w) \le 1024
\end{cases}$
Тобто, $L_{1024}$ - рекурсивно зліченна.




\end{document}

