% !TEX TS-program = xelatex
% !TEX encoding = UTF-8

\documentclass[11pt, a4paper]{article} % use larger type; default would be 10pt

\usepackage{fontspec} % Font selection for XeLaTeX; see fontspec.pdf for documentation
\defaultfontfeatures{Mapping=tex-text} % to support TeX conventions like ``---''
\usepackage{xunicode} % Unicode support for LaTeX character names (accents, European chars, etc)
\usepackage{xltxtra} % Extra customizations for XeLaTeX
\usepackage{tikz}
\usetikzlibrary{arrows,calc,patterns}
\usetikzlibrary{decorations.pathreplacing,calligraphy}

\setmainfont[Ligatures=TeX]{Garamond} % set the main body font (\textrm), assumes Charis SIL is installed
%\setsansfont{Deja Vu Sans}
\setmonofont[Ligatures=TeX]{Fira Code}

% other LaTeX packages.....
\usepackage{fullpage}
\usepackage[top=2cm, bottom=4.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd,systeme}
\usepackage{cancel}
\geometry{a4paper} 
%\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{multicol}

\renewcommand\lstlistingname{Algorithm}
\renewcommand\lstlistlistingname{Algorithms}
\def\lstlistingautorefname{Alg.}
\lstdefinestyle{mystyle}{
    % backgroundcolor=\color{backcolour},   
    % commentstyle=\color{codegreen},
    % keywordstyle=\color{magenta},
    % numberstyle=\tiny\color{codegray},
    % stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

\newcommand\course{5 - Complexity}
\newcommand\hwnumber{КР №2}                   % <-- homework number
\newcommand\idgroup{ФІ-91}                
\newcommand\idname{Михайло Корешков}  

\usepackage[framemethod=TikZ]{mdframed}
\mdfsetup{%
	backgroundcolor = black!5,
}
\mdfdefinestyle{ans}{%
    backgroundcolor = green!5,
    linecolor = green!50,
    linewidth = 1pt,
}

\pagestyle{fancyplain}
\headheight 35pt
\lhead{\idgroup \\ \idname}
\chead{\textbf{\Large \hwnumber}}
\rhead{\course \\ \today}
\lfoot{}
\cfoot{}
\rfoot{\small\thepage}
\headsep 1.5em

\linespread{1.2}

\begin{document}
\section*{1)}

\subsection*{a)}
\begin{mdframed}
    $$L_1 = \{<\alpha > \in \{0,1\}^* : \exists x: \text{  МТ  } T(M_\alpha,x) \le |\alpha | \}$$
\end{mdframed}

По-перше, $|<\alpha >| = \log \alpha$

Будуємо МТ $M_{L1}(\alpha)$:
\begin{itemize}
    \item $N = 1$
    \item Моделюємо роботу МТ $M_\alpha$ на вхідному слові $N$
    \item На $|\alpha|+1$ кроці підмашини:
    \subitem $N = N+1$ 
    \subitem Починаємо спочатку
    \item Якщо підмашина завершила роботу раніше, то повертаємо 1 та завершуємо роботу всієї МТ.
\end{itemize}
Якщо таке слово існує, то така МТ гарантовано рано чи пізно знайде його. 
Якщо не існує, то зациклюємося. Тобто, побудували розпізнавач $L_1$

Теорема Райса не застосовна, бо можемо робити $|\alpha|$ кроків вхолосту, а вирішувати ту саму мову

$$\overline{L_1} = \{<\alpha> : \forall x: \text{  МТ  } T(M_\alpha,x) > |\alpha |\}$$

$$M_{nL1}(M) = \begin{cases}
    1, & \forall x: T(M, x) > <M>\\
    \bot, & \exists x: T(M, x) \le <M>\\
\end{cases}$$

Нехай $a = |<M>|$

Нехай $M_{nL1}(M)$ - така, що:
\begin{enumerate}
    \item 
    Перебираємо усі $w \in \bigcup_{n=0}^{a} {0,1}^n$ - \textbf{скінченна} кількість слів
    \item
    Якщо на якомусь вході $M$ зупиняється менш, ніж за $a$ кроків, то повертаємо 0
    \item
    Інакше повертаємо 1
\end{enumerate}


Це працює, бо якщо на вхід $M$ йде слово $w$ довжини $|w|>a$, є такі варіанти:
\begin{itemize}
    \item $M$ завжди дає відповідь лише після читання $a < n \le |w|$ символів цього слова.\\
    У цьому випадку гарантовано робимо не менше $a$ кроків хоча б щоб прочитати слово. 
    Можна повертати 1, якщо ще не повернули 0 перебираючи слова розміру менше.
    \item Нехай $|w| > a$, $M$ на $w$ виконує $n < a$ кроків, та для всіх $w' : |w'|\le a$ $M$ робить більше 100 кроків.\\
    Тоді $M$ прочитала не більше $n < a$ символів слова $w$. 
    Але ми вже перевірили всі реакції $M$ на слова розміру менше $a$ і знаємо, що в таких випадках $M$ завжди робить більше $a$ кроків.
    Протиріччя. \\ Тобто $\forall w: |w| > a$, $M$ на $w$ виконує $n \ge a$ кроків
\end{itemize}

\begin{mdframed}[style=ans]
    Вирішувана
\end{mdframed}

\subsection*{1.b)}
$$L_2 = \{<M> : \forall x: x \text{ містить } 11 \implies M \text{ не приймає } x\}$$

$$\overline{L_2} = \{<M> : \exists x: x \text{ містить } 11 \wedge M \textbf{ приймає } x\}$$

Це не властивість мови:
Якщо $M_1 \in \overline{L_2}$, то можемо побудувати $M_2$ так, що вона приймає всі ті самі слова та ще якесь довільне, що не містить $11$.
Теорема Райса не застосовна.

$\overline{L_2}$ - наче розв'язна.

\begin{itemize}
    \item Занумеровуємо всі слова, які містять $11$: $W=\{w_n\}$
    \item Просто перебираємо слова поки не знайдемо $n: M(w_n) = 1$. 
    Якщо не знайдемо, то зациклюємося - все ок.
\end{itemize}


Нехай $L_2$ - розв'язна. Тобто існує
$$M_{L2}(M) = \begin{cases}
    1, & \forall x: x \text{ містить } 11 \implies M(x)=0\\
    \bot, & otherwise
\end{cases}$$
TODO


\section*{2.}
$$L_1, L_2, L_3 \in NPC \implies L_4 = (L_1^* \cup L_2) || L_3 \in NPC$$

$$L_0 \in NPC \iff \forall L_1 \in NP: L_1 \le L_0 \wedge L_0 \in NP$$

$L_4$ - "регулярна мова відносно $NPC$-мов", так би мовити. 
Звичайна регулярна мова розпізнається скінченним автоматом. Машини Тьюрінга сильніші за скінченні автомати.
Значить $L_4$ точно може розпізнатися машиною Тюрінга з оракулами для $L_1$, $L_2$ та $L_3$.

\begin{mdframed}
    Note
    $$L_1 \in NPC, L_2 \in NP, L_1 \le_p L_2 \implies L_2 \in NPC  $$
\end{mdframed}

TODO

\section*{4.}
$$NTIME(n^{14}) \subseteq DTIME(n^{75}) \implies EXP = NEXP$$

Нехай $EXP \ne NEXP$.
Тоді, за твердженням з лекції, $P \ne NP$.

TODO

\section*{3.}

\begin{itemize}
    \item $L_2 \in NPC$
    $$4-SAT = SAT = SAT SEARCH$$
    Запускаємо $SAT SEARCH$ 3 рази.

    $L_2 \in NPC \implies L_2 \notin P, L_2 \in NP, EXP$
    \item $L_1 \in P$
    шукаємо першу $11$ щоб дізнатись $n$ чи шукаємо $00$ якщо $m=0$. далі просто рахуємо, кіко набралось одиниць, а потім після них нулів.

    $L_1 \in P \implies L_1 \in NP, EXP$
\end{itemize}

\section*{5.}
$f(n)$ - не конструктивна ні за часом, ні за пам'яттю, бо $\frac{C}{n}$ спадає сильно швидко, швидше ніж $\log$ та $\log \log$, а $|\sin(...)|$ взагалі можна вважати константною $1$. 
Завжди настане якесь $n$ (може дуже велике) після якого не встигнемо прочитати все слово і МТ не зможе давати кожен раз правильну відповідь.

$g(n)$ - не конструктивна за часом, бо спадає швидше $O(n)$. Те саме.
конструктивна за пам'яттю, бо $g = \Omega(\log)$

\end{document}