% !TEX TS-program = xelatex
% !TEX encoding = UTF-8

\documentclass[11pt, a4paper]{article} % use larger type; default would be 10pt

\usepackage{fontspec} % Font selection for XeLaTeX; see fontspec.pdf for documentation
\defaultfontfeatures{Mapping=tex-text} % to support TeX conventions like ``---''
\usepackage{xunicode} % Unicode support for LaTeX character names (accents, European chars, etc)
\usepackage{xltxtra} % Extra customizations for XeLaTeX
\usepackage{tikz}

\setmainfont[Ligatures=TeX]{Garamond} % set the main body font (\textrm), assumes Charis SIL is installed
%\setsansfont{Deja Vu Sans}
\setmonofont[Ligatures=TeX]{Fira Code}

% other LaTeX packages.....
\usepackage{fullpage}
\usepackage[top=2cm, bottom=4.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd,systeme}
\geometry{a4paper} 
%\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{multicol}

\renewcommand\lstlistingname{Algorithm}
\renewcommand\lstlistlistingname{Algorithms}
\def\lstlistingautorefname{Alg.}
\lstdefinestyle{mystyle}{
    % backgroundcolor=\color{backcolour},   
    % commentstyle=\color{codegreen},
    % keywordstyle=\color{magenta},
    % numberstyle=\tiny\color{codegray},
    % stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

\newcommand\course{5 - Теорія складності}
\newcommand\hwnumber{ДЗ №2}                   % <-- homework number
\newcommand\idgroup{ФІ-91}                
\newcommand\idname{Михайло Корешков}  

\usepackage[framemethod=TikZ]{mdframed}
\mdfsetup{%
	backgroundcolor = black!5,
}
\mdfdefinestyle{ans}{%
    backgroundcolor = green!5,
    linecolor = green!50,
    linewidth = 1pt,
}

\pagestyle{fancyplain}
\headheight 35pt
\lhead{\idgroup \\ \idname}
\chead{\textbf{\Large \hwnumber}}
\rhead{\course \\ \today}
\lfoot{}
\cfoot{}
\rfoot{\small\thepage}
\headsep 1.5em

\linespread{1.2}

\begin{document}

\section*{№ 2.1}
Спочатку погрався з операціями, подивився що взагалі можливо.
Згодом відчув, що краще всього робити три послідовні операції
$$10 = f(v_1,g(v_2, h(v_3,v_4)))$$
бо інакше можливо використати лише дві
$$10 = f(g(v_1, v_2),h(v_3,v_4))$$
а цього, недостатньо ні для чого, схожого на 10

Отож, після ще 5 хвилин роздумів, я вирішив перебрати Python'ом всі
підходящі нам вирази вигляду 
$$f(v_1,g(v_2, h(v_3,v_4)))$$

Таким чином знайшов одну відповідь:
\begin{mdframed}[style=ans]
    $$10 = \frac{8}{1-\frac{1}{5}}$$    
\end{mdframed}

\section*{№ 2.2}
\begin{align*}
    & A = |\overline{\text{Black}}| = 14 \\  
    & B = |\overline{\text{White}}| = 16 \\  
    & C = |\overline{\text{Red}}| = 24 \\  
    & D = |\overline{\text{Green}}| = 12
\end{align*}

$|A \cup B \cup C \cup D|$ - кількість всіх кульок.

\begin{align*}
    |A \cup B \cup C \cup D| &= |A| + |B| + |C| + |D| - \\
        &- |A\cap B| - |A \cap C| - |A \cap D| - |B \cap C| - |B \cap D| - |C \cap D| + \\
        &+ |A \cap B \cap C| + |A \cap B \cap D| + |A \cap C \cap D| + |B \cap C \cap D| -\\
        &- |A\cap B \cap C\cap D| 
\end{align*}

\begin{itemize}
    \item $|A\cap B \cap C\cap D| = 0$, бо там не може бути кулька не червоного, не чорного, не білого та не зеленого кольору одночасно
    \item $|A \cap B \cap C| = |\text{Green}|$
    \item $|A \cap B \cap D| = |\text{Red}|$
    \item $|A \cap C \cap D| = |\text{White}|$
    \item $|B \cap C \cap D| = |\text{Black}|$
    \item $|A\cap B| = |\text{Red}| + |\text{Green}|$
    \item $|A\cap C| = |\text{White}| + |\text{Green}|$
    \item $|A\cap D| = |\text{White}| + |\text{Red}|$
    \item $|B\cap C| = |\text{Black}| + |\text{Green}|$
    \item $|B\cap D| = |\text{Black}| + |\text{Red}|$
    \item $|C\cap D| = |\text{Black}| + |\text{White}|$
\end{itemize}

$$|U| = |\text{White}| + |\text{Green}| + |\text{Black}| + |\text{Red}|$$
$$U = A \cup B \cup C \cup D$$


\begin{align*}
    |A \cup B \cup C \cup D| &= |A| + |B| + |C| + |D| - \\
        &- |\text{Red}| - |\text{Green}| - |\text{White}| - |\text{Green}| -\\
        &- |\text{White}| - |\text{Red}| - |\text{Black}| - |\text{Green}| - |\text{Black}| - |\text{Red}| - |\text{Black}| - |\text{White}| + \\
        &+ |\text{Green}| + |\text{Red}| + |\text{White}| + |\text{Black}| -\\
        &- 0
\end{align*}

\begin{align*}
    |U| &= |A| + |B| + |C| + |D| - \\
        &- 3|U| + \\
        &+ |U| -\\
        &- 0
\end{align*}

$$3|U| = |A| + |B| + |C| + |D|$$
\begin{mdframed}[style=ans]
    $$|U| = \frac{|A| + |B| + |C| + |D|}{3} = \frac{14 + 16 + 24 + 12}{3} = \frac{66}{3} = 22$$
\end{mdframed}


\section*{№ 2.3}
\subsection*{Сюди}
Нехай $M'$ - стандартна багатострічкова МТ з $k$ стрічками без видалення.
Будуємо $M$ - стандартну багатострічкову МТ.

$T(n) = T'(n)$, бо МТ без видалення спокійно працює як МТ з видаленням, просто не використовує цю можливість.

\subsection*{Туди}
Нехай $M$ - стандартна багатострічкова МТ з $k$ стрічками.
Будуємо $M'$ - багатострічкову МТ без видалення.

\begin{itemize}
    \item Вводимо новий символ "зовсім-не-\#", позначатимемо його "\$"
    \item Вводимо $k+1$-шу стрічку - "остаточну". На ній буде результат роботи. 
    \item В усіх інструкціях, де пишемо \#, тепер пишемо \$ (навіть, якщо залишаємо таким чином \# на місці) 
    \item В усіх інструкціях, де шукаємо \#, тепер шукаємо \# чи \$
\end{itemize}

Тут складність не змінилася. Лише додали нову стрічку та новий символ.

Важливо, що тепер можна однозначно визначити робочу область - вона буде обмежена \# праворуч та ліворуч. 
Знак \# не може стояти всередині робочої області, бо ми його проходили хоча б раз і замінили на \$. 

Також, всередині робочої області результуючої (k-ї) стрічки не може стояти \$, 
бо машина $M$ має дати результат без \# всередині слова.

Після закінчення роботи М:
\begin{itemize}
    \item Шукаємо початок робочої області $k$ї стрічки - просто перший \$ ліворуч
    \item Копіюємо цю результуючу стрічку в "остаточну" з наступного символа й до першої \$ праворуч
    \item Тепер результуюча стрічка містить слово без \$ всередині, обмежене нескінченними хвостами з \# - тобто правильно оформлений результат роботи МТ
\end{itemize}

Оцінуємо складність:
$$T'(n) \le T(n) + 2m \text{ , де $m$ - розмір результуючої стрічки}$$
$2m$ щоб в найскладнішому випадку пройти з правого краю робочої області останньої стрічки 
до лівого та знову праворуч доки її копіюємо

В найгіршому випадку, ми писали по символу в результуючу стрічку кожен такт, тобто її довжина = $T(n)$.
\begin{mdframed}[style=ans]
    $$T'(n) \le 3T(n)$$
\end{mdframed}

\section*{№ 2.5}
Машини в доданому файлі \texttt{2.5.py}

\section*{№ 2.6}
\subsection*{1. $f(n) = n$}
Вхід: $1^n$
Вихід: $1^f(n) = 1^n$

За домовленністю, на початку виконання зчитуючий пристрій на першому символі.
Тому просто читаємо вхідне слово до першого символу \#

Виконаємо рівно $n$ тактів та на виході матимемо те саме $1^n$ \qedsymbol

\subsection*{2. $f(n) = n \log n$}
Вхід: $1^n$
Вихід: $1^{n \log n}$

Розглянемо наступну МТ:
\begin{itemize}
    \item три додаткові стрічки: вхідна, "А", "Б", "В" та вихідна
    \item йдемо по вхідній стрічці та кожен другий символ пишемо в стрічку А
    \item коли дійшли до кінця вхідної стрічки, пишемо одиницю в стрічку В
    \item Маємо на стрічці А $1^{n/2}$
    \item Далі йдемо по стрічці А, затираючи одиниці, та пишемо в стрічку Б кожен другий символ. 
    Коли дійшли до кінця пишемо в стрічку В ще одиницю
    \item Йдемо по стрічці Б, затираючи одиниці, та пишемо в стрічку А кожен другий символ.
    Коли дійшли до кінця пишемо в стрічку В ще одиницю
    \item Продовжуємо поки довжина базової стрічки (яку ділимо на 2) не 1.
    \item Коли це відбулося, на стрічці В має бути $\log_2 n$
    \item Тепер копіюємо стрічку В на вихідну. Кожен раз коли доходимо до кінця, 
    рухаємось по вхідній стрічці на 1 та змінюємо напрям руху по стрічці В
\end{itemize}
В результаті, маємо $n \cdot \log n$ одиниць на виході.

К-сть тактів на обчислення логарифму:
$$
T_1 = n + n/2 + n/4 + ... + n/(2^{\log n}) = n\frac{1-2^{-\log n}}{1 - \frac{1}{2}} = 2n(1 - \frac{1}{n}) = 2n - 2
$$

К-сть тактів на запис $1^{n \log n}$:
$$
T_2 = n \log n + O(n)
$$

Отже
$$
T(n) = 2n - 2 + n \log n + O(n) = n \log n + O(n) = O(n \log n)
$$

Всі умови виконані \qedsymbol

\subsection*{3. $f(n) = n^2$}

Вхід: $1^n$

\begin{itemize}
    \item Копіюємо вхідну стрічку на стрічку А
    \item Йдемо по стрічці А записуючи 1 на кожному кроці на вихідну стрічку
    \item Коли доходимо до кінця стрічки А, рухаємось на 1 далі на вхідній стрічці
    \item Йдемо по стрічці А до іншого кінця
    \item Повторюємо поки не дійдемо до кінця вхідної стрічки
\end{itemize}
На вихідній стрічці буде $n^2$ одиниць.

Виконаємо $T(n) = n^2 + O(n)$ кроків, тобто $T(n) = O(n^2)$.

Всі умови виконані \qedsymbol

\subsection*{4. $f(n) = 2^n$}

\begin{enumerate}
    \item На вхідній стрічці n одиниць
    \item Пишемо одну одиницю на стрічку А
    \item Ставимо зчитуючий пристрій на останній символ вхідного слова
    \item Після цього на стрічку Б пишемо 2 одиниці за кожну одиницю стрічки А
    \item Коли доходимо до кінця, рухаємо на 1 зчитувач вхідної стрічки
    \item Пишемо по 2 одиниці на стрічку А за кожну одиницю стрічки Б.
    \item Коли доходимо до кінця, рухаємо на 1 зчитувач вхідної стрічки
    \item Повторюємо 4-7 це доки не дійдемо до кінця вхідної стрічки
    \item Тепер копіюємо стрічку, на яку тільки що писали, в результуючу стрічку
\end{enumerate}

В результаті ми n разів подвоїли к-сть одиниць, починаючи з однієї. 
Маємо $2^n$ одиниць.

Ми зробили 
$$
T(n) = 2^n + 2 + 4 + 8 + ... + 2^n + O(n) = 2^n + 2^{(n+1)}-1 + O(n) = 3 \cdot 2^n + O(n) = O(2^n) 
$$
тактів

Всі умови виконані \qedsymbol

\section*{№ 2.7}
Нехай $\lceil \log n \rceil$ - конструктивна за часом. 
Тобто
$$T(n) = O(\lceil \log n \rceil)$$
$$M(1^n) = 1^{\lceil \log n \rceil}$$

Помітимо, що $\exists C:\; T(n) \le C \cdot \lceil \log n \rceil$.

Також помітимо, що $\forall C:\; \exists N:\; \forall n>N:\; n > C \cdot \lceil \log n \rceil$.

Візьмемо таке $q$, щоб $\exists a,b, a<b:\; \begin{cases}
    2^q+a &< \lceil C \cdot \log (2^q+a) \rceil = C \cdot (q+1) \\
    2^q+b &> \lceil C \cdot \log (2^q+b) \rceil = C \cdot (q+1)
\end{cases}$.\\

Тобто для слів довжини до $2^q+a$ МТ встигне зчитати все слово, а після $2^q+b$ - ні.



\textbf{TODO}

% \textbf{Протиріччя.}

% Отже, $f(n) = \lceil \log n \rceil$ не є конструктивною за часом

\section*{№ 2.8}
\begin{mdframed}
    \textbf{1.} $f(n)$ - конструктивна за часом якщо
    $$
    \begin{cases}
        T_M(n) = O(f(n)) \\
        M(1^n) = 1^{f(n)}
    \end{cases}
    $$
\end{mdframed}

\begin{mdframed}
    \textbf{2.} $f(n)$ - конструктивна за часом якщо
    $$ \exists n_0:\; \forall n > n_0:\;
    \begin{cases}
        T_M(n) = O(f(n)) \\
        T_M(\{1^n\}) = f(n)
    \end{cases}
    $$
\end{mdframed}

\begin{mdframed}
    \textbf{3.} $f(n)$ - конструктивна за часом якщо
    $$\forall n:\;
    \begin{cases}
        T_M(n) = O(f(n)) \\
        \exists w:\; |w|=n \;:\; T_M(\{w\}) = f(n)
    \end{cases}
    $$
\end{mdframed}

\begin{mdframed}
    \textbf{4.} $f(n)$ - конструктивна якщо
    $$\forall n:\;
    \begin{cases}
        T_M(n) = O(f(n)) \\
        M(1^n) = \operatorname{bin}(f(n))
    \end{cases}
    $$
\end{mdframed}

\subsection*{2 => 1}
На вході $1^n$
Пишемо одиницю на результуючій стрічці кожен такт. 
Маємо $T_M(\{w\}) = f(n)$ одиниць.

Тобто, побудували нову МТ, що виконує умови 1. \;\qedsymbol

\subsection*{1 => 4}
Спочатку треба дізнатися, наскільки складний перехід між двійковим та одиничним представленням числа.

Додавання одиниці: перейти до наймолодшого 0 та фліпнути в 1. Занулити всі молодші за нього одиниці.

\begin{itemize}
    \item В половині випадків це буде фліп 0-розряду - 1 такт
    \item В чверті випадків - фліп 1 розряду та занулення 0 розряду - 2 такти
    \item 1/8 випадків - фліп 2 розряду та занулення молодших розрядів - 3 такти
    \item $n/2^{k}$ - $k$ тактів
\end{itemize}

Тобто $$T_{1\to 2}(n) = O(n(1/2 + 2/4 + 3/8 + ... + k/2^k + ...)) \le C\cdot n \sum_{k=1}^\infty \frac{k}{2^k} = C \cdot n\cdot S$$
$$
\sum_{k=1}^\infty \frac{k}{2^{k+1}} = \frac{1}{2} \sum_{k=1}^\infty \frac{k}{2^{k}} = S/2 = \sum_{k=2}^\infty \frac{k-1}{2^k} = S - \frac{1}{2} \; | \cdot 2
$$
$$
S = 2S - 1 \implies S = 1
$$
Отож, вартість переходу з унарної до бінарної системи
$$ T_{1 \to 2}(n) = O(n) $$

Нехай в нас записано $1^{f(n)}$ за $T(n) = O(f(n))$ тактів.
Для переписування його в бінарну систему потрібно ще $O(f(n))$ тактів.
Маємо $T'(n) = O(f(n)) + O(f(n)) = O(f(n))$ \;\qedsymbol

\subsection*{4 => 1}
Можна віднімати 1 від бінарного числа доки не залишиться 0.
Разом з цим кожен раз додавати 1 до вихідного слова. 

Віднімання 1 це фліп наймолодшої 1 в 0 та фліп всіх молодших за неї нулів в 1.
Аналогічно попередньому пункту, 
$$T_{2 \to 1}(n) = O(n)\;\text{ , де $n$ - довжина бінарного числа}$$

Отже, $T'(n) = O(f(n)) + O(\log f(n)) = O(f(n))$ \;\qedsymbol

\subsection*{2=>3}
Просто беремо $w = 1^n$\;\qedsymbol

\section*{№ 2.9}
\subsection*{$f(n)+g(n)$}
Будуємо наступну МТ:

Беремо всі стрічки першої МТ, всі стрічки другої МТ.
Запускаємо одночасно, чекаємо завершення виконання. 
Виконали $T'(n) = max(T_1(n), T_2(n)) \le T_1(n) + T_2(n)$ тактів. 

В результуючих стрічках кожної МТ маємо рядок з одиниць. 
Записуємо спочатку всі одиниці однієї МТ, потім дописуємо всі одиниці другої.
Маємо $1^{f(n) + g(n)}$

При цьому 
$$T''(n) = T'(n) + O(f(n) + g(n)) = O(O(f(n)) + O(g(n))) + O(f(n) + g(n)) = O(f(n) + g(n))$$

Тобто, всі умови конструктивності виконані. \qedsymbol

\subsection*{$f(n)g(n)$}
Виконуємо послідовно дві МТ. Маємо два результати на окремих стрічках. Потім:
\begin{itemize}
    \item Йдемо на початок обох вихідних стрічок
    \item Йдемо по першій до кінця записуючи кожен такт 1 на остаточну стрічку
    \item Коли доходимо до її кінця, рухаємось на 1 на другій стрічці
    \item Знову йдемо до (іншого) кінця першої стрічки записуючи 1 кожен такт.
    \item Продовжуємо доки не дійшли до кінця другої стрічки
    \item В результаті матимемо $1^{f(n)g(n)}$ на остаточній стрічці
\end{itemize} 

$$
T(n) = O(f(n)) + O(g(n)) + O(f(n)g(n))
$$
$$ f(n)g(n) = O(f(n)),\; O(g(n)) $$
$$ T(n) = O(f(n)g(n)) $$

Всі умови виконані. \; \qedsymbol

\subsection*{$g(f(n))$}

\begin{itemize}
    \item Виконуємо першу МТ
    \item Її результат ($1^{f(n)}$) беремо як вхід другої МТ
    \item Маємо $1^{g(f(n))}$ у вихідній стрічці.
\end{itemize}

Нехай $n = O(g(n))$
$$T(n) = O(f(n)) + O(g(f(n))) = O(g(f(n))) + O(g(f(n))) = O(g(f(n)))$$

Інакше може бути, що $g(f(n)) = o(f(n))$ \; \qedhere

\subsection*{$2^{f(n)}$}
\begin{itemize}
    \item Обчислюємо $M(1^n) = 1^m$ - $T_1 = O(f(n))$
    \item Обчислюємо $1^{2^m}$ як в 2.6 - $T_2 = O(2^{f(n)})$
\end{itemize}

$$
T(n) = O(f(n)) + O(2^{f(n)}) = O(2^{f(n)})
$$
\qedhere

\subsection*{$f(n)^{g(n)}$}
\begin{itemize}
    \item Обчислюємо $M_f(1^n) = 1^f$ - $T_1 = O(f(n))$
    \item Обчислюємо $M_g(1^n) = 1^g$ - $T_2 = O(g(n))$
    \item Копіюємо результат виконання $M_f$ на нову стрічку ("А")
    \item Ставимо зчитувальник на стрічці $M_g$ на початок
    \item Записуємо кожну одиницю стрічки А на стрічку Б $f(n)$ разів (використовуємо стрічку $M_f$ як лічильник).
    \item Рухаємо на 1 зчитувальник стрічки $M_g$
    \item Записуємо кожну одиницю стрічки Б на стрічку А $f(n)$ разів (використовуємо стрічку $M_f$ як лічильник).
    \item Рухаємо на 1 зчитувальник стрічки $M_g$
    \item Продовжуємо подібним чином доки не закінчиться стрічка $M_g$
\end{itemize}
В результаті маємо $f(n)^{g(n)}$ одиниць.
Думаю, безпечно припустити, що $f(n),\; g(n) \; = O(f(n)^{g(n)})$
$$
T(n) = O(f(n)) + O(g(n)) + O(f(n)^{g(n)}) = O(f(n)^{g(n)})
$$
\qedsymbol


\section*{№ 2.10}
Аналогічно 2.7

\begin{mdframed}
    $f(n)$ - конструктивна за пам'яттю якщо для деякої стандартної багатострічкової МТ:
    $$
    \begin{cases}
        S(n) = O(f(n)) \\
        M(1^n) = 1^{f(n)}
    \end{cases}
    $$
\end{mdframed}

\section*{№ 2.11}
Переводимо вхідне слово $1^n$ як унарне число в бінарне число.

Маємо $1^{\lfloor \log n \rfloor + 1}$

Якщо $n = 2^k$ (напр. коли всі нулі окрім останнього символа) - видаляємо один символ с кінця.

Заміняємо всі 0 на 1.

Тепер маємо $1 ^ {\lceil \log n \rceil}$. \;\qedsymbol


\end{document}

