% !TEX TS-program = xelatex
% !TEX encoding = UTF-8

\documentclass[11pt, a4paper]{article} % use larger type; default would be 10pt

\usepackage{fontspec} % Font selection for XeLaTeX; see fontspec.pdf for documentation
\defaultfontfeatures{Mapping=tex-text} % to support TeX conventions like ``---''
\usepackage{xunicode} % Unicode support for LaTeX character names (accents, European chars, etc)
\usepackage{xltxtra} % Extra customizations for XeLaTeX
\usepackage{tikz}
\usetikzlibrary{arrows,calc,patterns}

\setmainfont[Ligatures=TeX]{Garamond} % set the main body font (\textrm), assumes Charis SIL is installed
%\setsansfont{Deja Vu Sans}
\setmonofont[Ligatures=TeX]{Fira Code}

% other LaTeX packages.....
\usepackage{fullpage}
\usepackage[top=2cm, bottom=4.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd,systeme}
\usepackage{cancel}
\geometry{a4paper} 
%\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{multicol}

\renewcommand\lstlistingname{Algorithm}
\renewcommand\lstlistlistingname{Algorithms}
\def\lstlistingautorefname{Alg.}
\lstdefinestyle{mystyle}{
    % backgroundcolor=\color{backcolour},   
    % commentstyle=\color{codegreen},
    % keywordstyle=\color{magenta},
    % numberstyle=\tiny\color{codegray},
    % stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

\newcommand\course{5 - Аналіз алгоритмів}
\newcommand\hwnumber{ДЗ №3}                   % <-- homework number
\newcommand\idgroup{ФІ-91}                
\newcommand\idname{Михайло Корешков}  

\usepackage[framemethod=TikZ]{mdframed}
\mdfsetup{%
	backgroundcolor = black!5,
}
\mdfdefinestyle{ans}{%
    backgroundcolor = green!5,
    linecolor = green!50,
    linewidth = 1pt,
}

\pagestyle{fancyplain}
\headheight 35pt
\lhead{\idgroup \\ \idname}
\chead{\textbf{\Large \hwnumber}}
\rhead{\course \\ \today}
\lfoot{}
\cfoot{}
\rfoot{\small\thepage}
\headsep 1.5em

\linespread{1.2}

\begin{document}

\section*{№ 2.3}
\subsection*{a) Знайдiть мультиплiкативну та адитивну складнiсть пiднесення m-цифрового
числа до квадрату}

\begin{mdframed}
    Нехай:\\
    Складність додавання - $O(add)$\\
    Складність множення - $O(mul)$
\end{mdframed}

$$\begin{matrix}
    0 & 0 & ... & 0 & x_{n-1} & x_{n-2} & ... & x_2 & x_1 & x_0 \\
    0 & 0 & ... & 0 & x_{n-1} & x_{n-2} & ... & x_2 & x_1 & x_0 \\
    \hline \\
    c_0^{2n-1} & c_0^{2n-2} & ... & c_0^{n} & c_0^{n-1} & c_0^{n-2} & ... & c_0^2 & c_0^1 & c_0^0 \\
    c_1^{2n-1} & c_1^{2n-2} & ... & c_1^{n} & c_0^{n-1} & c_1^{n-2} & ... & c_1^2 & c_1^1 & c_1^0 \\
    ...\\
    c_{n-1}^{2n-1} & c_{n-1}^{2n-2} & ... & c_{n-1}^{n} & c_{n-1}^{n-1} & c_{n-1}^{n-2} & ... & c_{n-1}^2 & c_{n-1}^1 & c_{n-1}^0 \\
    \hline \\
    0 & 0 & ... & 0 & z_{n-1} & z_{n-2} & ... & z_2 & z_1 & z_0
\end{matrix}$$

Кожен рядок матриці $c_i^j$ утворюємо множенням першого числа на $i$-й розряд другого та зсувом ліворуч на $i$ позицій.

\begin{mdframed}[backgroundcolor=violet!15]
    \textbf{Твердження 1:}
    $$c_k^{2n-1} = c_k^{2n-2} = ... = c_k^{n+k+1} = 0$$

    Помножимо перший рядок на $10^{k+1}$. \\
    Матимемо $c_k^{n+k} = x_{n-1}$, а $c_k^{n+k+1} = c_k^{n+k+2} = ... c_k^{2n-1} = 0$.
    
    А при множенні на $9 \cdot 10^k < 10^{k+1}$ буде зайнято не більше розрядів.
    \qedsymbol
\end{mdframed}

Тобто маємо наступну картину

$$\begin{matrix}
    0 & 0 & ... & 0 & x_{n-1} & x_{n-2} & ... & x_2 & x_1 & x_0 \\
    0 & 0 & ... & 0 & x_{n-1} & x_{n-2} & ... & x_2 & x_1 & x_0 \\
    \hline \\
    0 & 0 & ... & c_0^{n} & c_0^{n-1} & c_0^{n-2} & ... & c_0^2 & c_0^1 & c_0^0 \\
    0 & 0 & ... & c_1^{n} & c_0^{n-1} & c_1^{n-2} & ... & c_1^2 & c_1^1 & 0 \\
    ...\\
    c_{n-1}^{2n-1} & c_{n-1}^{2n-2} & ... & c_{n-1}^{n} & c_{n-1}^{n-1} & 0 & ... & 0 & 0 & 0 \\
    \hline \\
    z_{2n-1} & z_{2n-2} & ... & z_n & z_{n-1} & z_{n-2} & ... & z_2 & z_1 & z_0
\end{matrix}$$

% $$x^2 = (\sum_{i=0}^{n-1} x_i \beta^i)(\sum_{i=0}^{n-1} x_i \beta^i) = 2 \cdot \sum_{0\le i < j \le n-1} x_ix_j\beta^{i+j} + \sum_{k=0}^{n-1} x_k^2 \beta^{2k} = $$
% $$= 2 \sum_{i=0}^{n-2} \sum_{j=i+1}^{n-1} x_ix_{j} \beta^{i+j} + \sum_{k=0}^{n-1} x_k^2 \beta^{2k} = $$
% Нехай $p = i+j$. $p=\overline{1,2n-3}$. Тоді $j = p-i$.

% ---
% $$= 2 \sum_{p=1}^{2n-3} \sum_{j=\left\lfloor \frac{p-1}{2} \right\lfloor}^{n-1} x_ix_{j} \beta^{i+j} + \sum_{k=0}^{n-1} x_k^2 \beta^{2k} = $$

% ---

% $$= 2 \sum_{p=1}^{2n-3} \sum_{j=\frac{p+1}{2}}^{n-1} x_{p-j}x_{j} \beta^{p} + \sum_{k=0}^{n-1} x_k^2 \beta^{2k} = $$
% Оптимізуємо. Нехай $\sum_{i=1}^{n-1} x_ix_{p-i} = X_{p}$
% $$\sum_{p=1}^{2n-3}  \beta^p \sum_{i=1}^{n-1} x_ix_{p-i} = \sum_{p=1}^{2n-3}  \beta^p X_{p} = $$
% $$= (( ... (((X_{2n-3} \cdot \beta) + X_{2n-4})\cdot \beta + X_{2n-5})\cdot \beta + ... ) \cdot \beta + X_1)\cdot \beta$$

\pagebreak

Алгоритм множення двох чисел:
\begin{lstlisting}
    c = zeros(2n-1)
    for i = 0 to n-1:
        carry = 0
        for j = 0 to n-1:
            // Додаємо до відповіді добуток числа на i-й розряд
            (carry, c[i,j]) = c[i+j] + xx[i,j] + carry

            // max_carry_1 <= (9 + 9*9 + 9)//10 = (18+81)//10 = 99//10 = 9
            // carry <= 9
            // Тобто все ок, величина переносу поміщається в один розряд

        // додаємо цифру переносу. 
        // цей розряд ще не чіпали, тому просто присвоєння, не "+="
        c[i+n] = carry

    return c    // c[0..2n-1] містить результат множення
\end{lstlisting}

\textbf{Можемо попередньо обчислити всі добутки цифр.}

\begin{lstlisting}
    c = zeros(2n-1)

    xx = zeros(n,n)
    for i = 0 to n-1:
        for j = i to n-1:
            xx[i,j] = xx[j,i] = x[i] * x[j]
            // Економимо половину операцій через симетрію xx

    for i = 0 to n-1:
        carry = 0
        for j = 0 to n-1:
            // Додаємо до відповіді добуток числа на i-й розряд
            (carry, c[i,j]) = c[i+j] + xx[i,j] + carry

            // max carry <= (9 + 9*9 + 9)//10 = (18+81)//10 = 99//10 = 9
            // carry <= 9
            // Тобто все ок, величина переносу поміщається в один розряд

        // додаємо цифру переносу. 
        // цей розряд ще не чіпали, тому просто присвоєння, не "+="
        c[i+n] = carry

    return c    // c[0..2n-1] містить результат множення
\end{lstlisting}

Складність:
\begin{itemize}
    \item Мультиплікативна:\\
    Лише передобчислення масиву \texttt{xx[i,j]} - $N_{\times} = \frac{n(n-1)}{2}$
    \item Адитивна:\\
    На кожній ітерації внутрішнього циклу - $N^i_{+} = 2 = O(1)$\\
    Всього ітерацій - $(n-1)^2$\\
    Всього додавань - $N_{+} = 2(n-1)^2 = O(n^2)$
\end{itemize}

Якщо вважати, що додавання знехтовно швидка операція порівняно з множенням, 
то складність всього піднесення до квадрату - $O(n^2)$

\subsection*{b)}

$$A = 4 xy = (x+y)^2 - (x-y)^2 = x^2 + 2xy + y^2 - x^2 +2xy - y^2$$
$$xy = \frac{A}{4}$$

Складність $A/4$ - $O(n)$ (якщо попередньо обчислити результати ділення на 2 чисел до 20, бо просто один прохід long division)\\
Складність $(x+y)^2 - (x-y)^2$ - $2sq(n)$, де $sq(n)$ - складність піднесення до квадрату

Тобто, складність множення $= \Omega($ складність квадрату $)$

складність квадрату = $O($складність множення$)$ \qedsymbol


\section*{№ 2.4}
\begin{mdframed}
    Обчислiть бiтову складнiсть операцiй множення та дiлення m-цифрового натурального числа на 2. 
    Вважайте, що система числення має основу $2^w$
\end{mdframed}

$$x = x^{m-1}x^{m-2}\cdots x^1 x^0, \quad x^i \in \{0,1,\cdots , 2^w - 1\}$$

1 разряд $x$ відповідає одному бітовому регістру розміру $w$.
Тобто 
$$x = \boxed{x_{w-1}^{m-1} \cdots x_0^{m-1}} \boxed{x_{w-1}^{m-2} \cdots x_0^{m-2}} \cdots \boxed{x_{w-1}^{0} \cdots x_0^{0}} $$ 
де $x^i_j \in \{0,1\}$

Ділення/множення на 2 - це просто bitwise shift на 1 праворуч/ліворуч (в молодший/старший бік)

\subsection*{Ділення на 2}
Схема роботи:
\begin{enumerate}
    \item Зсунути старший регістр >> 1
    \item Зберегти молодший біт старшого регістру в старший біт наступного вже зсунутого регістру\\
    Останній біт - \texttt{x[1] \& 1}\\
    Додати в старший біт наступного регістра - \texttt{y[0] = (x[0] >> 1) | ((x[1] \& 1) << w-1)}\\
    Можна спростити: \texttt{y[0] = (x[0] >> 1) | (x[1] << w-1)}
\end{enumerate}

\begin{lstlisting}
    // y[i] - iй регістр, нумерація як вище
    // y[i][j] - jй біт i-го регістру, нумерація як вище
    // x - вхід, y - вихід

    y[m-1] := x[m-1] >> 1                       // 1 op
    for i = m-2 to 0:                           // m-1 ітерацій
        y[i] := (x[i] >> 1) | (x[i+1] << w-1)   // 3 ops
\end{lstlisting}

В результаті, $$T(n) = 1 + 3(m-1)$$

\subsection*{Множення на 2}
Схема роботи:
\begin{enumerate}
    \item Зсунути молодший регістр << 1
    \item Зберегти старший біт молодшого регістру в молодший біт попередього вже зсунутого регістру\\
    Старший біт - \texttt{x[0] \& (1<<w-1)}\\
    Додати в молодший біт попередього регістра - \texttt{y[1] = (x[1] << 1) | ((x[0] \& (1<<w-1)) >> w-1)}\\
    Можна спростити: \texttt{y[1] = (x[1] << 1) | (x[0] >> w-1)}
\end{enumerate}

\begin{lstlisting}
    // y[i] - iй регістр, нумерація як вище
    // y[i][j] - jй біт i-го регістру, нумерація як вище
    // x - вхід, y - вихід

    y[0] := x[0] << 1                           // 1 op
    for i = 1 to m-1:                           // m-1 ітерацій
        y[i] := (x[i] << 1) | (x[i-1] >> w-1)   // 3 ops
\end{lstlisting}

В результаті, $$T(n) = 1 + 3(m-1)$$

\pagebreak

\section*{№ 2.5}
$$C = \frac{X}{Y}$$
$X, Y$ - $n$ та $m$ цифрові числа в $2^w$-системі числення

Нехай регістр має розмір $w$

\begin{lstlisting}
    R = X
    Q = 0
    while R >= Y:                 // T_bit = |R| = |X|, бо це як віднімання
        t = |R|
        C = Y << |R| - |Y|        // T_bit = T_shift(|Y|) * (|R| - |Y|)
        if R < C:                 // T_bit = |X|, бо це як віднімання
            t = t-1               // 1
            C = Y << t - |Y|      // T_bit = T_shift(|Y|) * (t - |Y|)
        R = R - C                 // |R| = |X|
        Q = Q + (1 << t - |Y|)    // |Q| + 1
    
    // T_shift(|Y|) = 1 + 3(|Y|-1) = 3|Y| - 2
    // |Q| = |X| - |Y|
\end{lstlisting}

Найвища складність коли віднімання відбувається кожну ітерацію. 
Вважаємо, що цикл виконається $|X| - |Y|$ ітерацій
$$T_{max}(|X|,|Y|) = |X| + (|X| - |Y|)\cdot (|X| + (3|Y| - 2)\cdot(|X|-|Y|) + |X| + |X| - |Y| + 1) = $$
$$= n + (n-m)\cdot (3n + (3m-2)\cdot (n-m) - m + 1) = $$
$$=3 m^3 - 6 m^2 n - m^2 + 3 m n^2 - m + n^2 + 2 n = $$
$$=O(mn^2)$$
Бо $n > m$

\section*{№ 2.7}

$$\beta = 2^w - \text{база системи числення}$$
$$x^y - ?$$
$$|x|_w = \text{к-сть розрядів в $\beta$-системі числення} = \lfloor\log_\beta |x| + 1\rfloor$$
$$|x|_2 = \text{к-сть розрядів (бітів) в $2$-системі числення} = w\cdot |x|_w$$
$$|x|_r = \text{к-сть n-бітних регістрів для запису числа} = \lceil|x|_2/n\rceil$$

Базова операція - множення двох n-бітних чисел

Let $t = |y|_w$
$$x^y = x^{\left( \sum_{i=0}^{t-1} y_i 2^{wi} \right)} = $$
$$= x^{2^{w(t-1)}y_{t-1}}\cdot x^{2^{w(t-2)}y_{t-2}} \cdot ... \cdot x^{2^{w\cdot 1}y_1} \cdot x^{2^{0}y_0} = $$
$$= (( ... ((x^{y_{t-1}})^{2^{w}} \cdot x^{y_{t-2}})^{2^{w}} \cdot ... )^{2^{w}} \cdot x^{y_1})^{2^{w}} \cdot x^{y_0}$$

В обчисленні задіяні наступні операції
\begin{enumerate}
    \item множення довгих чисел
        \subitem $a \cdot b$ 
    \item $x^{y_i}$ - одне і те саме число до різних степенів зі скінченного набору
    \item $(...)^{2^w}$ - $w$ разів піднесення до квадрату
\end{enumerate}

\subsection*{1. Shift-and-add}
$$a \cdot b$$
$$|a|_r = u,\quad |b|_r = v$$

\begin{lstlisting}
    1011   (this is binary for decimal 11)
  x 1110   (this is binary for decimal 14)
  ======
    0000   (this is 1011 x 0)
   1011    (this is 1011 x 1, shifted one position to the left)
  1011     (this is 1011 x 1, shifted two positions to the left)
+ 1011      (this is 1011 x 1, shifted three positions to the left)
=========
10011010   (this is binary for decimal 154)
\end{lstlisting}

Algorithm:
\begin{lstlisting}
    IN: a, b
        a: [a_u-1][a_u-2]...[a_0] - u n-bit registers
        b: [b_v-1][b_v-2]...[b_0] - v n-bit registers
    OUT: c = a*b
        c: [c_q-1][c_q-2]...[c_0] - (q=u+v) n-bit registers

    c = 0
    for i = 0 to v-1:         // iterate through b's registers 
        shift = 0
        for j = 0 to u-1:     // iterate through a's registers 
            c += (a_i * b_j) << shift  
            shift += n
\end{lstlisting}

Кількість множень відносно регістрової довжини множників:
$$T_{mul}(|a|_r,|b|_r) = |a|_r \cdot |b|_r$$

\subsection*{2. $x^{y_i}$}
Можна обчислити всі можливі значення заздалегідь:

\begin{lstlisting}
    pows: [x^(2^w -1), x^(2^w-2), ..., x^1, x^0]
    len(pows) = 2^w

    pows[0] = 1
    for i = 1 to 2^w-1:
        pows[i] = pows[i-1] * x
\end{lstlisting}

Складність $pows[i-1] * x$ залежить від регістрової довжини операндів.
$$|pows[i]|_r = \lceil\frac{2^w \cdot |x|_2}{n}\rceil$$
$$T_1 = T_{mul}(|pows[i]|_r, |x|_r) = |pows[i]|_r \cdot |x|_r$$

Складність обчислення всіх степенів:
$$T_{pows} = T_1 \cdot (2^w-1) = |pows[i]|_r \cdot |x|_r \cdot (2^w-1)$$

\subsection*{3. $a^{2w}$}
Це $2^w$ разів піднести до квадрату.
$$T_{**2^w}(|a|_r) = 2^w \cdot |a|_r^2$$

\subsection*{Збираємо все разом}

Розмір результату в регістрах - $|result|_r = |x|_r \cdot y$

Algorithm
\begin{lstlisting}
    precalculate_pows()       // T_pows

    result = x^(y[t-1])
    for i = t-1 to 0:
        result = result^(2^w)          // T_{\text{^}2^w}
        result = result * pows[y[i]]   // T_mul(|x|_r \cdot y, |pows[i]|_r)
    return result
\end{lstlisting}

Складність:
$$T = T_pows + y_|w| \cdot \left(T_{**2^w} + T_mul(|x|_r \cdot y, |pows[i]|_r)\right) = $$
$$= |pows[i]|_r \cdot |x|_r \cdot (2^w-1) + y_|w| \cdot (2^w \cdot (|x|_r \cdot y)^2 +  |x|_r \cdot y \cdot \lceil\frac{2^w \cdot |x|_2}{n}\rceil) $$



\section*{№  2.10}
\begin{mdframed}
    Нехай N — m-цифрове натуральне число. 
    Знайдiть мультиплiкативну складнiсть обчислення N! шляхом безпосереднього множення.
\end{mdframed}

$$log N = m$$
$$R = N!$$
$$R = N*(N-1)*(N-2)* ... * 2 * 1$$

Довжина $(N-k)$ - це $\log (N-k)$

Всього: $$T(m) = \sum_{k=0}^{N-1} T_{mul}(\log (N-k)) = O\left(\sum_{k=0}^{N-1} \log (N-k)\right)$$

По-перше, ясно, що $T(m) = O(N \log N) = O(Nm)$

По-друге, 
$$\sum_{k=0}^{N-1} \log (N-k) \to \int_0^{N-1} \log (N-k) dk = $$
$$= - k - (N-k)\log (N-k) |_0^{N-1} 
= N\log N - N + 1 = O(N\log N)$$

Тобто
$$T(m) = O(N\log N) = O(m\beta^m)$$

\end{document}

