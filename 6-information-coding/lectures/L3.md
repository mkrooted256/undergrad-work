# Лекція 3

Код Хафмана найбільш оптимальний, коли частоти символів дорівнюють (від'ємним) степеням двійки. В такому випадку довжина коду символа дорівнює $\log_2 p_i$
$$L = \sum_i p_i \log_2 p_i = H$$

Код Хафмана неоптимальний, наприклад, коли два символи зустрічаються з сильно різними частотами
```
0000000000100000000
```

Тут може стати корисним **RLE** - Run Length Encoding.  
```
... <symbol><symbol_len> <symbol><symbol_len> ...
```
(При чому `symbol_len` якоїсь фіксованої довжини)

> Коди хафмана - 50-ті роки.  
Арифметичне кодування - 70-ті роки

## Арифметичне кодування

> спосіб дати символу менше 1 біта в середньому

> в кінці рядка обов'язково 

Ідея в тому, щоб побудувати $f: M \to [0;1]$, M - всі можливі повідомлення.

Нехай  
```p(a) = 0.5; p(b)=0.3; p(c)=p(#)=0.1; m=abc#```
```
|--       a        --|--    b    --|-- c --|-- # --|
0                    0.5           0.8     0.9     1
```

Кодуємо повідовлення "abc#".
```
1) Кодуємо a:
0                                          0.5           0.8     0.9     1
|--       a                              --|--    b    --|-- c --|-- # --|
|--    a   --|--    b    --|-- c --|-- # --|
0            0.25         0.4    0.45     0.5

2) Кодуємо b:
0    0.25                                               0.4    0.45     0.5
|- a -|--    b                                         --|-- c --|-- # --|
      |--       a        --|--    b    --|-- c --|-- # --|
      0.25                0.325          0.37    0.385    0.4

3) c:
0.25  0.325 0.37                                             0.385    0.4
|- a -|- b -|--  c                                            --|-- # --|
            |--       a        --|--    b     --|-- c --|-- # --|
            0.37                0.362          0.37    0.3835   0.385

4) #:
0.37  0.362   0.37   0.3835                                 0.385
|-- a--|-- b --|-- c --|--              #                   --|
                       |--    a    --|-- b  --|-- c --|-- # --|
                      0.3835        0.384     x       x     0.385

```
Результат: 0.384


Що робити коли наближаємось до максимальної точності?

```
4') #:

з 3 кроку:
|--       a        --|--    b     --|-- c --|-- # --|
0.37                0.362          0.37    0.3835   0.385

Res: 0.3


0.7  0.62    0.7      0.835                                 0.8385
|-- a--|-- b --|-- c --|--              #                   --|
                       |--    a    --|-- b  --|-- c --|-- # --|
                       0.835        0.8384    x       x     0.8385

Res: (8; 0.384)

```

Вважається, що цей метод - еталон потужності стиснення.

Недолік - алгоритм дуже ресурсозатратний та довгий.

Згодом розробили алгоритм, що працює майже так само добре, як класичне арифметичне кодування, але зі швидкістю порядку Хафмана.
Цей алгоритм базується на асиметричних системах числення.

## ANS / TANS - (Tabular) Asymmetric Numerical System

(Arithmetic Encoding без фігні накшталт ділення, переповнення регістрів та купи нюансів)

> Часто на практиці частоти беруться приблизні, через степені двійки

Нехай ```p(a)=1/8; p(b)=5/8; p(c)=2/8;```

```
  |  0  1  2  3  4  5  6  7 |  8  9 10 11 12 13 14 15 |
a |  0                      |  1                      |
b |     0  1  2  3  4       |     5  6  7  8  9       |
c |                    0  1 |                    2  3 |
```
Ядро алгоритму - `y=E(s,x)` - кодувальна функція. `x` - поточний символ, `s` - наступний символ.

`Lmin(s), Lmax(s)` - макс та мін число в таблиці (правій, робочій, частині), що відповідає `s`.  
`Lmin >= Lmax`

`Lmin(c)=2; Lmax(c)=3`

**Encoding**
```
 1. read(s)
 2. x = Lmin(s)
 3. while !eof:
 4.   x = E(s,x)
 5.   read(s)
      # перевіряємо, чи потрібно робити редукцію
 6.   while x > Lmax(s):
 7.      output(x mod 2)
 8.      x = x div 2
 9. x = E(s,x)
10. reduce x to 1
```

```
E(s,x) = <номер стовпця, що містить число x в рядку s>
```

Приклад
```
M = "cab"

s := 'c'
x := Lmin('c') = 2
x := E('c',2) = 14

s := 'a'
14 > Lmax('a') = 1
reduction:
  14 -> 7 -> 3 -> 1
  0     1    1
x := E('a', 1) = 8

s := 'b'
x := E('b', 8) = 12

end reduction:
12 -> 6 -> 3 -> 1
0     0    1

Output: 011001
```

> виводимо числа лише під час редукції

Декодування (виконується з кінця повідомлення)
```
1. x := 1
2. while !bof (beginning of file)
3.   while x < L
4.     read(s)
5.     x := 2x + s
6.   (s, x) := D(x)
7.   output(s)
```

Приклад (декодування попереднього прикладу):
```
In: 011001

x := 1
read 1.  x = 2*1 + 1 = 3
read 0.  x = 2*3 + 0 = 6
read 0.  x = 2*6 + 0 = 12
(s,x) = D(12) = ('b', 8)
output 'b'
(s,x) = D(8) = ('a', 1)
output 'a'
read 1. x = 2*1 + 1 = 3
read 1. x = 2*3 + 1 = 7
read 0. x = 2*7 + 0 = 14
(s,x) = D(14) = ('c', 2)
output 'c'
end
```

```
D(n) = (E^-1)(n) = ((s,x) : E(s,x)=n)
```

